name: FastAPI Docker CI/CD Pipeline

on:
  # Trigger: Allows manual execution from the GitHub Actions tab
  workflow_dispatch:
  # Trigger: Automatic execution on push to main branch
  push:
    branches:
      - main

jobs:
  # ------------------------------------------------
  # JOB 1: Continuous Integration (CI)
  # Builds the Docker image and pushes it to the registry
  # ------------------------------------------------
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üê≥ Login to Docker Hub
        uses: docker/login-action@v3
        with:
          # Use secrets defined in GitHub repository settings
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üèóÔ∏è Build and Push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          # The image tag for the final container
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/astro-app:fit-api-latest
            ${{ secrets.DOCKERHUB_USERNAME }}/astro-app:fit-api-${{ github.sha }}

  # ------------------------------------------------
  # JOB 2: Continuous Deployment (CD)
  # Deploys the new image via SSH on the Linux server
  # ------------------------------------------------
  deploy:
    needs: build-and-push # Ensures this job starts only after a successful build
    runs-on: ubuntu-latest
    steps:
      - name: üíª Deploy new Docker image via SSH
        uses: appleboy/ssh-action@v1.0.1
        with:
          # SSH connection secrets
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}

          # Commands to execute on your Linux server:
          script: |
            IMAGE_TAG=${{ secrets.DOCKERHUB_USERNAME }}/astro-app:fit-api-${{ github.sha }}
            IMAGE_TAG_LATEST=${{ secrets.DOCKERHUB_USERNAME }}/astro-app:fit-api-latest
            LIVE_CONTAINER_NAME=fit_api_live
            NEW_CONTAINER_NAME=fit_api_staging
            REDIS_CONTAINER_NAME=fit_api_redis
            CREDENTIALS_FILE=/tmp/google-credentials.json
            NETWORK_NAME=fit_api_network
            CONTAINER_CREDS_PATH=/app/keys/fit-analyze-480219-1f7156c9487e.json

            # üí° FINAL PORT: The application runs here
            LIVE_PORT=8000
            # üí° TEMPORARY PORT: Used for the health check
            STAGING_PORT=8001
            # üí° REDIS PORT
            REDIS_PORT=6379

            echo "0. Logging into Docker Hub..."
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

            echo "1. Writing Google Cloud credentials to file..."
            # Create credentials file from secret
            echo '${{ secrets.GOOGLE_CREDENTIALS }}' > $CREDENTIALS_FILE
            chmod 600 $CREDENTIALS_FILE

            echo "2. Ensuring Docker network exists..."
            # Create Docker network if it doesn't exist
            docker network inspect $NETWORK_NAME >/dev/null 2>&1 || docker network create $NETWORK_NAME

            echo "3. Ensuring Redis is running..."
            # Check if Redis container exists and is running, if not start it
            if [ ! "$(docker ps -q -f name=$REDIS_CONTAINER_NAME)" ]; then
              echo "   Starting Redis container..."
              docker run -d \
                --name $REDIS_CONTAINER_NAME \
                --network $NETWORK_NAME \
                -p $REDIS_PORT:6379 \
                --restart always \
                redis:alpine
            else
              echo "   Redis container already running."
              # Ensure it's connected to the network
              docker network connect $NETWORK_NAME $REDIS_CONTAINER_NAME 2>/dev/null || true
            fi

            echo "4. Pulling new image from Docker Hub..."
            # Use SHA-specific tag to ensure we get the exact new build
            docker pull $IMAGE_TAG
            # Also pull latest for reference
            docker pull $IMAGE_TAG_LATEST

            echo "5. Starting new container alongside the old one on port $STAGING_PORT..."
            # Start the new container on the staging port using SHA-specific tag
            docker run -d \
              --name $NEW_CONTAINER_NAME \
              --network $NETWORK_NAME \
              -p $STAGING_PORT:8000 \
              -v $CREDENTIALS_FILE:$CONTAINER_CREDS_PATH:ro \
              -e REDIS_URL=redis://$REDIS_CONTAINER_NAME:6379 \
              -e GOOGLE_APPLICATION_CREDENTIALS=$CONTAINER_CREDS_PATH \
              -e BIGQUERY_PROJECT_ID=${{ secrets.BIGQUERY_PROJECT_ID }} \
              -e BIGQUERY_DATASET=${{ secrets.BIGQUERY_DATASET }} \
              --restart on-failure \
              $IMAGE_TAG

            echo "6. Health check - waiting for new container to be ready..."
            # Check container status
            echo "   Container status:"
            docker ps -a | grep $NEW_CONTAINER_NAME || true

            # Show container logs for debugging
            echo "   Container logs:"
            docker logs $NEW_CONTAINER_NAME || true

            # Wait longer and retry health check multiple times
            echo "   Waiting 15 seconds for container startup..."
            sleep 15

            # Try health check with retries
            HEALTH_CHECK_PASSED=false
            for i in {1..5}; do
              echo "   Health check attempt $i/5..."
              if wget --spider -q http://localhost:$STAGING_PORT/docs 2>/dev/null; then
                HEALTH_CHECK_PASSED=true
                break
              fi
              echo "   Attempt $i failed, waiting 5 more seconds..."
              sleep 5
            done

            if [ "$HEALTH_CHECK_PASSED" = false ]; then
              echo "‚ùå Health check failed on port $STAGING_PORT after 5 attempts! Rolling back..."
              echo "   Final container logs:"
              docker logs --tail 50 $NEW_CONTAINER_NAME || true
              docker stop $NEW_CONTAINER_NAME || true
              docker rm $NEW_CONTAINER_NAME || true
              exit 1
            fi
            echo "‚úÖ Health check passed!"

            echo "7. Switching to new container (zero-downtime attempt)..."

            # --- Stop/Remove Old Container (Frees up port 8000) ---
            echo "   Stopping and removing old container ($LIVE_CONTAINER_NAME)..."
            docker stop $LIVE_CONTAINER_NAME || true
            docker rm $LIVE_CONTAINER_NAME || true

            # --- Rerun Staging Container on Live Port (8000) and Rename ---
            # Stop the temporary container (to free up $STAGING_PORT)
            docker stop $NEW_CONTAINER_NAME
            docker rm $NEW_CONTAINER_NAME

            # Start the container again, now using the final LIVE_PORT (8000:8000) with SHA-specific tag
            docker run -d \
              --name $LIVE_CONTAINER_NAME \
              --network $NETWORK_NAME \
              -p $LIVE_PORT:8000 \
              -v $CREDENTIALS_FILE:$CONTAINER_CREDS_PATH:ro \
              -e REDIS_URL=redis://$REDIS_CONTAINER_NAME:6379 \
              -e GOOGLE_APPLICATION_CREDENTIALS=$CONTAINER_CREDS_PATH \
              -e BIGQUERY_PROJECT_ID=${{ secrets.BIGQUERY_PROJECT_ID }} \
              -e BIGQUERY_DATASET=${{ secrets.BIGQUERY_DATASET }} \
              --restart always \
              $IMAGE_TAG

            echo "8. Cleaning up credentials file..."
            # Note: Keep credentials file for running container, it will be overwritten on next deployment

            echo "9. Cleaning up old Docker images..."
            docker image prune -af --filter "until=24h"

            echo "10. Logging out from Docker Hub..."
            docker logout

            echo "‚úÖ Deployment finished successfully!"
            echo "üì¶ Deployed image: $IMAGE_TAG"
